\documentclass[12pt, letterpaper]
{article}

\include{inc/packages.inc}
\include{inc/personalize.inc}
\include{inc/style.inc}


\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}

% \pagestyle{plain}
\pagestyle{fancy}
\fancyhf{}
\fancyhfoffset[L]{1cm} % left extra length
\fancyhfoffset[R]{1cm} % right extra length
\rhead{\thepage}
\lhead{\nouppercase\leftmark}
\cfoot{\fancyplain{}{\thepage} }

\begin{document}
\nocite{*}

\pagenumbering{gobble}
% \include{inc/title.inc}

% \tableofcontents
% \newpage
\newcounter{lastroman}
\setcounter{lastroman}{\value{page}}
\pagenumbering{arabic}
\maketitle
\begin{abstract}
    The Maintaining Arc Consistency (MAC) algorithm is used to solve the Constraint Propagation (CSP) problem in a nonogram game. The MAC algorithm uses the Minimum Remaining Values (MRV) heuristic to order the search tree. The AC-3 algorithm used as pre-processing. The results demonstrate that the MAC algorithm is effective at solving 5x5 nonograms but loses accuracy at with nonograms of size 10x10 and above and also takes more time to solve as the puzzle size increases.
\end{abstract}
\section{Problem Definition}
%talk about csps, ac3 and mrv
    This project will measure the efficiency of the CSP algorithm by measuring its performance at solving a kind of puzzle known as nonograms.  Nonograms are grid based puzzles in which the player must determine if the cells are to be filled in or left blank. Grids can be any rectangular shape but are typically found as squares (N x N) where N is a multiple of 5. Whether a cell is filled or not is determined by sequence of numbers aligned with the rows and columns of the grid. If a sequence contains a single number, the associated line will contain that number of filled squares in a row. If a sequence contains 2 or more numbers, that line contains an uninterrupted line of squares equal to each number, followed by at least one empty space between each number in the order that those numbers appear. For example, the first row of the below nonogram contains only a three, therefore the first row has three cells in a row filled in. The second line contains a one followed by a  three, therefore it gets one square filled in followed by a line of three.


\begin{figure}[H]
    \centering
    {\includegraphics[width=0.4\linewidth]{fig/nonogram.png}}\hfill
    {\includegraphics[width=0.4\linewidth]{fig/canvas.png}}
        \caption{An example nonogram and solution}
    \label{fig:example-nono}
\end{figure}

    Nonograms make for great problems to be solved by AI. The board and whether any square is determined to be filled, blank (denoted with an X), or unknown(left blank) is fully observable. As the solver is acting alone it will only have a single agent. The solver determines which squares are filled or not making them deterministic. Nonograms are sequential as squares being marked filled or blank will affect the possible outcome for other squares. Lastly as nonograms have well-defined rules they can be considered known environments. 
    
    An AI-based nonogram solver can be useful as a component for computer nonogram games. It can provide a player answers if they get stuck or be used to dynamically create puzzles with valid solutions.

    \subsection{Constraint Satisfaction Problems}
    Nonograms will be structured as Constraint Satisfaction Problems (CSPs). CSPs are made up of three components: a set of variables, $X$, set of domains for each variable, $D$, and a set of constraints that are allowable combinations of values, $C$. Applying these principles to a nonogram: each row of the puzzle will be a variable. Based on the clues for a row, every possible combination of filled and unfilled cells will be found which will then compose the domain for that row. The constraints will be defined by the column clues; if each cell in a row creates a valid column, that value satisfies the constraint.

    The Maintaining Arc Consistency (MAC) algorithm will be used to solve the CSPs generated by nonograms. MAC incorporates 3 concepts: backtracking search, the AC-3 algorithm and the MRV heuristic.

    Backtracking search models a CSP as a depth first search tree; nodes represent variables and arc represent a constraint between two variables. In addition, backtracking search makes two considerations. The first is that CSPs are commutative; it doesn't matter which order assignments are made in, only requiring a single variable to be assigned at each level of the tree. The second is that values are only assigned to variables if they don't conflict with previously assigned variables.
    The AC-3 algorithm will be used before backtracking search begins as pre-processing and then run again after each variable assignment. The purpose of AC-3 is to enforce arc-consistency in the search tree; this means that each variable's domain satisfies its constraints. A queue of all arcs in the CSP is created using tail, head notation. An arc is popped from the queue and checked if it is consistent. If it is the queue moves to the next arc, if not invalid values are removed from the tail. All arcs of constraints that point to the tail are then added to the queue. This repeats until either a domain is reduced to zero, and it is determined that the CSP has no consistent solution, or no more arcs are in the queue and the CSP is solved.

    The Minimum Remaining Values(MRV) heuristic will be used to order the search tree. This selects variables with the smallest domain first. It is also known as the 'fail-first' heuristic as it will select a variable with no legal values in its domain first and detect failure as immediately as it arrives. \cite{russell_artificial_2022}






\section{Previous Work}
    Manyam et al \cite{10863160} applied algorithms to solve Sudoku puzzles. As nonograms have well-defined rules like sudoku, similar studies can be conducted. Backtracking, Ant Colony Optimization(ACO) and Constraint Propagation Algorithms were implemented. They applied each of these algorithms to 9x9, 16x16 and 25 x 25 sudoku puzzles. A GUI for a sudoku game was created using the Pygame framework. The player can attempt to solve the puzzle themselves and when they get stuck, click on a button that will trigger an algorithm to solve the puzzle.

    The first algorithm that they implemented was Backtracking. The algorithm placed numbers in empty cells and upon reaching a conflict, backtracked by trying a different number in the cell. Branched that break constraints (the rules of sudoku) are pruned to increase efficiency. This is continued until either the puzzle is solved or every possibility is explored, and no solution can be found.

    ACO is implemented by simulating the behavior of ants. As cells are filled a "pheromone level" is assigned. The more likely to be valid that an entry is, the higher its pheromone level. Higher pheromone levels are more likely to be picked by future ants. Each cycle pheromone levels get updated and cells are filled accordingly until a solution is found, or all possibilities are exhausted.

    Lastly constraint propagation initialized the grid with possible values for empty cells and deletes impossible values to find cells that can be inferred with sudoku solving techniques. Invalid paths are eliminated, and the cycle repeats until the puzzle is solved.

    The results show that for girds sized 9x9 Constraint Propagation is the most efficient and for larger grids, ACO is the most efficient.

\section{Methodology}
%Expand on this
The performance of the AC-3 algorithm using the MRV heuristic to solve nonograms was measured. The metrics to measure performance were execution time and accuracy. Accuracy was measured by comparing the results of the algorithm to the real solution of the nonograms.

The AC-3 algorithm was implemented in a command line Python program based on a Java program used for a class assignment. Nonogram clues were supplied to the program in a CSV file. The first column of the csv represents clues for rows and the second column represents clues for columns. Clues were entered in the order they appear; top to bottom for rows, left to right for columns. Each individual number in a clue is separated with a space. Using figure \ref{fig:example-nono} as an example, a csv for its clues would be the following:
\begin{figure}[H]
    \caption{A nonogram's clues encoded into a csv}
    \begin{lstlisting}
    3,3
    1 3,1 2
    1 1,2 1
    2 2,2 2
    3,3
    \end{lstlisting}
\end{figure}
For the accuracy comparison the solved nonogram was also provided. It was formatted as a text file with \# representing filled cells and . representing blank cells. Each character has a leading space. Figure \ref{fig:example-nono}'s solution will be represented as shown:

\begin{figure}[H]
    \caption{A nonogram's solution encoded into a text file}
    \begin{lstlisting}
     . # # # .
     # . # # #
     # . . . #
     # # . # #
     . # # # .
    \end{lstlisting}
\end{figure}

% 

The possible rows were calculated by taking the number of segments(each number in a clue) with the necessary blank spaces and calculating all possible combinations of positions those segments can take in a row. Before search began, AC-3 is run as pre-processing. It calls a revise function to remove any conflicting values from the tail. Conflicting values are found by comparing the tail and head to the possible columns generated earlier. Each cell in the tail and head is compared with the corresponding cells in a possibility for a column. If the cells compose a possible column the algorithm moves to the next column. If the cells don't compose the possibility the algorithm checks another possibility for that column. If the head and tail don't make up any possibilities for that column the algorithm returns that there is a conflict and that tail value is deleted from the domain.


\begin{figure}[H]
    \caption{Conflict Algorithm}
    \label{code.1}
    \begin{lstlisting}[language=Python]
    def find_conflict(self, tail_index, tail, head_index, head):
           
        conflict = False
        # get row num of tail and head
        #for each value of tail and head
        for i in range(len(tail)):
            column_possibilities = self.col_constraints[i]
            for column in column_possibilities:
                if column[tail_index] != tail[i] or column[head_index] != head[i]:
                    # if last column possibility return true
                    if column_possibilities.index(column) + 1 == len(column_possibilities):
                        return True
                    # try another column if there's a conflict
                    else:
                        continue
                    
                else:
                    break
        return conflict
    \end{lstlisting}
\end{figure}

After AC-3 preprocessing was run, the search algorithm begins and applies backtracking search. It uses MRV to begin with the variable with the smallest domain first, and then runs AC-3 again after each assignment.

Once there are no more unassigned variables, the program's solved nonogram is printed in the same format as the true solution, as well as the time elapsed and the accuracy. This program was used to solve nonograms of the following sizes: 5x5, 10x10, 15x15, and 25x25. The program will be run 3 times for each nonogram and an average of times and accuracies will be calculated.

\section{Results}
\begin{table}[!ht]
    \caption{Average time and accuracy results for each nonogram size}
    \centering
    \begin{tabular}{lll}
    \hline
        \textbf{Size} & \textbf{Time} & \textbf{Accuracy} \\ \hline
        5x5 & 0.00355 & 100\% \\ 
        10x10 & 0.0386 & 89\% \\ 
        15x15 & 81.1 & 92.2\% \\ 
        25x25 & 7030 & 88.3 \\ \hline
    \end{tabular}
\end{table}

The results demonstrate the effectiveness of the MAC algorithm at solving nonograms of various sizes. 

5x5 nonograms were solved the quickest and were the only size solved with 100\% accuracy. On average all other sizes were solved with 89.5\% accuracy with no trends being seen in accordance with size. There was a relationship between time and size, with time to solve increasing as the size of the puzzles increases.

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=True solution for a 15x15 nonogram,frame=tlrb]{Name}
 . . . # . # . # . . . # . . #
 . . # # # # # # # . . # . # .
 . # # . . . . . # # . # # # #
 . # . . . . . . . # . . . . .
 . # # . # . # # # # # # # # #
 . . # . . . # . . . . . . . .
 . . # # . . # . . # # # # # #
 . . . # # . # # . # # # # # #
 . . . # . . # # . # . # . . #
 # # # # . . # # . # # # # # #
 # . # # . . # . . . . . . . .
 . . . # # # # # # # # # # # #
 . . . . . . . . . # . # . . .
 . # # # # # # # # # # # # # #
 # # . . . . . . . . . . . . #
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption= Program solution for a 15x15 nonogram,frame=tlrb]{Name}
 # . # . . # . . . . . # . . #
 # # # # # # # . . . . # . # .
 . # # . . . . . # # . # # # #
 . . . . . . . # . # . . . . .
 # # . # . . # # # # # # # # #
 . . # . . . # . . . . . . . .
 . . # # . . # . . # # # # # #
 . . # # . . # # . # # # # # #
 . . . # . . # # . # . # . . #
 # # # # . . # # . # # # # # #
 # . # # . . # . . . . . . . .
 . . . # # # # # # # # # # # #
 . . . . . . . . . # . # . . .
 . # # # # # # # # # # # # # #
 # # . . . . . . . . . . . . #
\end{lstlisting}
\end{minipage}


\section{Conclusion}
Outside of 5x5 nonograms, MAC isn't an effective method to solve them. At larger sizes solutions are inaccurate and take a large amount of time. This wouldn't be a user-friendly method of providing hints in a digital nonogram game. Other algorithms can possibly be used to increase both accuracy and efficiency.

\pagebreak
\appendix
\section{Appendix}
\subsection{Github Repository}
\begin{itemize}
 \item \href{https://github.com/drossano/ac3-nonogram/}{https://github.com/drossano/ac3-nonogram/}
\end{itemize}
\subsection{Raw Data}
\begin{table}[!ht]
    \centering
    \begin{tabular}{lll}
    \hline
        \textbf{Size} & \textbf{Time} & \textbf{Accuracy} \\ \hline
        5x5 & 0.00354 & 100\% \\ 
        5x5 & 0.00351 & 100\% \\ 
        5x5 & 0.00361 & 100\% \\ 
        10x10 & 0.0339 & 89 \\ 
        10x10 & 0.0469 & 89 \\ 
        10x10 & 0.0349 & 89 \\ 
        15x15 & 82.2 & 92.9 \\ 
        15x15 & 79.8 & 92.9 \\ 
        15x15 & 81.2 & 92.9 \\ 
        25x25 & 6770 & 88.3 \\ 
        25x25 & 6860 & 88.3 \\ 
        25x25 & 7470 & 88.3 \\ \hline
    \end{tabular}
\end{table}
% % Anhang
% \renewcommand{\thesubsection}{\Alph{subsection}}
% \pagenumbering{Roman}
% \setcounter{page}{\value{lastroman}}
% \section*{Appendix}
% \addcontentsline{toc}{section}{Appendix}

% %Abk√ºrzungsverzeichnis
% \input{inc/shorts.inc}
% \newpage

% %Code
% \input{inc/code_template.inc}
% \newpage
% \listoffigures
% \listoftables


%Bibliographie
\addcontentsline{toc}{section}{References}
\bibliographystyle{alpha}
\bibliography{bib/sources}

\end{document}